using Beamable.AccountManagement;
using Beamable.Api;
using Beamable.Api.Auth;
using Beamable.Api.Caches;
using Beamable.Api.Sessions;
using Beamable.Api.Stats;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Auth;
using Beamable.Common.Api.Stats;
using Beamable.Common.Dependencies;
using Beamable.Common.Player;
using Beamable.Stats;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Beamable.Player
{

	/// <summary>
	/// The <see cref="PlayerAccount"/> contains information about a player's
	/// credentials and basic account details, such as their <see cref="_alias"/>,
	/// <see cref="_email"/>, and <see cref="gamerTag"/>
	/// </summary>
	[Serializable]
	public class PlayerAccount : DefaultObservable, IUserContext
	{

		#region autogenerated equality checks
		protected bool Equals(PlayerAccount other)
		{
			return _alias == other._alias && _avatar == other._avatar && _subtext == other._subtext && GamerTag == other.GamerTag && _language == other._language && Equals(_deviceIds, other._deviceIds) && Equals(_scopes, other._scopes) && _email == other._email && Equals(_thirdParties, other._thirdParties) && Equals(_externalIdentities, other._externalIdentities) && Equals(token, other.token);
		}

		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj))
			{
				return false;
			}

			if (ReferenceEquals(this, obj))
			{
				return true;
			}

			if (obj.GetType() != this.GetType())
			{
				return false;
			}

			return Equals((PlayerAccount)obj);
		}

		public override int GetHashCode()
		{
			unchecked
			{
				var hashCode = (_alias != null ? _alias.GetHashCode() : 0);
				hashCode = (hashCode * 397) ^ (_avatar != null ? _avatar.GetHashCode() : 0);
				hashCode = (hashCode * 397) ^ (_subtext != null ? _subtext.GetHashCode() : 0);
				hashCode = (hashCode * 397) ^ _gamerTag.GetHashCode();
				hashCode = (hashCode * 397) ^ (int)_language;
				hashCode = (hashCode * 397) ^ (_deviceIds != null ? _deviceIds.GetHashCode() : 0);
				hashCode = (hashCode * 397) ^ (_scopes != null ? _scopes.GetHashCode() : 0);
				hashCode = (hashCode * 397) ^ (_email != null ? _email.GetHashCode() : 0);
				hashCode = (hashCode * 397) ^ (_thirdParties != null ? _thirdParties.GetHashCode() : 0);
				hashCode = (hashCode * 397) ^ (_externalIdentities != null ? _externalIdentities.GetHashCode() : 0);
				hashCode = (hashCode * 397) ^ (token != null ? token.GetHashCode() : 0);
				return hashCode;
			}
		}

		#endregion

		private readonly PlayerAccounts _collection;
		internal User _user;
		internal UserExtensions.StatCollection _stats;

		/// <summary>
		/// The alias of the current account. 
		/// This can be used as a display name.
		/// To change the alias, use <see cref="SetAlias"/>
		/// </summary>
		public string Alias => _alias;
		[SerializeField]
		private string _alias;

		/// <summary>
		/// The avatar used for this account.
		/// See the <see cref="AvatarConfiguration"/> for more details.
		/// To change the avatar, use <see cref="SetAvatar"/>
		/// </summary>
		public string Avatar => _avatar;
		[SerializeField]
		private string _avatar;

		/// <summary>
		/// The subtext for the current player can be used to share a small amount
		/// of account detail, like "level" or "progress".
		/// To change the subtext, use <see cref="SetSubtext"/>
		/// </summary>
		public string SubText => _subtext;
		[SerializeField]
		private string _subtext;

		/// <summary>
		/// The gamerTag for the given player.
		/// GamerTags are associated with a specific realm.
		/// This value should not be modified.
		/// </summary>
		public long GamerTag => _gamerTag;
		[SerializeField]
		private long _gamerTag;

		/// <summary>
		/// The player's language preference
		/// To change the language, use <see cref="SetLanguage"/>
		/// </summary>
		public SystemLanguage Language => _language;
		[SerializeField]
		private SystemLanguage _language;

		/// <summary>
		/// The set of deviceIds that have been associated with the given player.
		/// A player could have more than one deviceId if they played on multiple devices.
		/// Use the <see cref="HasDeviceId"/> to check if a deviceId is present.
		/// To add a deviceId, use the <see cref="AddDeviceId"/> method.
		/// To remove a deviceId, use the <see cref="RemoveDeviceId"/> method, and to remove all, use the <see cref="RemoveAllDeviceIds"/> method.
		/// </summary>
		public string[] DeviceIds => _deviceIds;
		[SerializeField]
		private string[] _deviceIds;

		/// <summary>
		/// The player's permission scopes. For most players, this will always be empty.
		/// However, for testers, developers, and admins, this will hold the permission.
		/// </summary>
		public string[] Scopes => _scopes;
		[SerializeField]
		private string[] _scopes;

		/// <summary>
		/// The email address associated with this account.
		/// Add an email with the <see cref="AddEmail"/> method.
		/// </summary>
		public string Email => _email;
		[SerializeField]
		private string _email;

		/// <summary>
		/// The set of standard Beamable third parties that have been associated with the given player.
		/// Add a third party with the <see cref="AddThirdParty"/> method.
		/// </summary>
		public AuthThirdParty[] ThirdParties => _thirdParties;
		private AuthThirdParty[] _thirdParties;

		/// <summary>
		/// The set of external identities that have been associated with the given player.
		/// Add an external identity with the <see cref="AddExternalIdentity"/> method.
		/// </summary>
		public ExternalIdentity[] ExternalIdentities => _externalIdentities;
		[SerializeField]
		private ExternalIdentity[] _externalIdentities;

		/// <summary>
		/// True when the account has an <see cref="_email"/>.
		/// </summary>
		public bool HasEmail => !string.IsNullOrEmpty(_email);

		/// <summary>
		/// True when the account has the given <see cref="AuthThirdParty"/>
		/// </summary>
		/// <param name="thirdParty"></param>
		/// <returns></returns>
		public bool HasThirdParty(AuthThirdParty thirdParty) => _thirdParties?.Contains(thirdParty) ?? false;

		/// <summary>
		/// True when there is at least 1 deviceId.
		/// </summary>
		public bool HasDeviceId => _deviceIds?.Length > 0;


		/// <summary>
		/// Given a combo of Microservice and Third Party Cloud Identity, this method will
		/// return true if the user has a credential associated with the provider.
		/// </summary>
		/// <typeparam name="TCloudIdentity">A <see cref="IThirdPartyCloudIdentity"/> type</typeparam>
		/// <typeparam name="TService">A <see cref="Microservice"/> that implements <see cref="TCloudIdentity"/></typeparam>
		/// <returns>true if the user has an existing association with the <see cref="TCloudIdentity"/></returns>
		public bool HasExternalIdentity<TCloudIdentity, TService>()
			where TCloudIdentity : IThirdPartyCloudIdentity, new()
			where TService : IHaveServiceName, ISupportsFederatedLogin<TCloudIdentity> =>
			TryGetExternalIdentity<TCloudIdentity, TService>(out _);

		/// <summary>
		/// Given a combo of Microservice and Third Party Cloud Identity, this method will
		/// return true if the user has a credential associated with the provider. Additionally, the <see cref="ExternalIdentity"/>
		/// is available as an out parameter
		/// </summary>
		/// <param name="identity"></param>
		/// <typeparam name="TCloudIdentity">A <see cref="IThirdPartyCloudIdentity"/> type</typeparam>
		/// <typeparam name="TService">A <see cref="Microservice"/> that implements <see cref="TCloudIdentity"/></typeparam>
		/// <returns>true if the user has an existing association with the <see cref="TCloudIdentity"/></returns>
		public bool TryGetExternalIdentity<TCloudIdentity, TService>(out ExternalIdentity identity)
			where TCloudIdentity : IThirdPartyCloudIdentity, new()
			where TService : IHaveServiceName, ISupportsFederatedLogin<TCloudIdentity>
		{
			var client = _collection._provider.GetService<TService>();
			var ident = new TCloudIdentity();
			identity = null;
			for (var i = 0; i < _externalIdentities.Length; i++)
			{
				var external = _externalIdentities[i];
				var namespaceMath = external.providerNamespace == ident.UniqueName;
				var serviceMatch = external.providerService == client.ServiceName;

				if (namespaceMath && serviceMatch)
				{
					identity = external;
					return true;
				}
			}

			return false;
		}

		/// <summary>
		/// The access token used for this account.
		/// </summary>
		public BeamableToken token;

		public PlayerAccount(PlayerAccounts collection, BeamableToken token, User user, UserExtensions.StatCollection stats)
		{
			_collection = collection;
			Update(user);
			Update(stats);
			this.token = token;
			TryTriggerUpdate();
		}

		/// <inheritdoc cref="PlayerAccounts.SwitchToAccount"/>
		public async Promise SwitchToAccount()
		{
			await _collection.SwitchToAccount(this);
		}

		/// <inheritdoc cref="PlayerAccounts.RemoveAccount"/>
		public async Promise Remove()
		{
			await _collection.RemoveAccount(this);
		}

		/// <inheritdoc cref="PlayerAccounts.SetAlias"/>
		public Promise<PlayerAccount> SetAlias(string alias)
		{
			return _collection.SetAlias(alias, this);
		}

		/// <inheritdoc cref="PlayerAccounts.SetAvatar"/>
		public Promise<PlayerAccount> SetAvatar(string avatar)
		{
			return _collection.SetAvatar(avatar, this);
		}

		/// <inheritdoc cref="PlayerAccounts.SetSubtext"/>
		public Promise<PlayerAccount> SetSubtext(string subtext)
		{
			return _collection.SetSubtext(subtext, this);
		}

		/// <inheritdoc cref="PlayerAccounts.AddEmail"/>
		public Promise<RegistrationResult> AddEmail(string email, string password)
		{
			return _collection.AddEmail(email, password, this);
		}

		/// <inheritdoc cref="PlayerAccounts.AddDeviceId"/>
		public Promise<RegistrationResult> AddDeviceId()
		{
			return _collection.AddDeviceId(this);
		}

		/// <inheritdoc cref="PlayerAccounts.RemoveDeviceId"/>
		public Promise<PlayerAccount> RemoveDeviceId()
		{
			return _collection.RemoveDeviceId(this);
		}

		/// <inheritdoc cref="PlayerAccounts.RemoveAllDeviceIds"/>
		public Promise<PlayerAccount> RemoveAllDeviceIds()
		{
			return _collection.RemoveAllDeviceIds(this);
		}

		/// <inheritdoc cref="PlayerAccounts.AddThirdParty"/>
		public Promise<RegistrationResult> AddThirdParty(AuthThirdParty thirdParty, string token)
		{
			return _collection.AddThirdParty(thirdParty, token, this);
		}

		/// <inheritdoc cref="PlayerAccounts.RemoveThirdParty"/>
		public Promise<PlayerAccount> RemoveThirdParty(AuthThirdParty thirdParty, string token)
		{
			return _collection.RemoveThirdParty(thirdParty, token, this);
		}


		/// <inheritdoc cref="PlayerAccounts.AddExternalIdentity"/>
		public Promise<RegistrationResult> AddExternalIdentity<TCloudIdentity, TService>(string token, ChallengeHandler challengeHandler)
			where TCloudIdentity : IThirdPartyCloudIdentity, new()
			where TService : IHaveServiceName, ISupportsFederatedLogin<TCloudIdentity>
		{
			return _collection.AddExternalIdentity<TCloudIdentity, TService>(token, challengeHandler);
		}

		/// <inheritdoc cref="PlayerAccounts.AddExternalIdentity"/>
		public Promise<RegistrationResult> AddExternalIdentity<TCloudIdentity, TService>(string token, AsyncChallengeHandler challengeHandler = null)
			where TCloudIdentity : IThirdPartyCloudIdentity, new()
			where TService : IHaveServiceName, ISupportsFederatedLogin<TCloudIdentity>
		{
			return _collection.AddExternalIdentity<TCloudIdentity, TService>(token, challengeHandler);
		}

		/// <inheritdoc cref="PlayerAccounts.RemoveExternalIdentity"/>
		public Promise<PlayerAccount> RemoveExternalIdentity<TCloudIdentity, TService>()
			where TCloudIdentity : IThirdPartyCloudIdentity, new()
			where TService : IHaveServiceName, ISupportsFederatedLogin<TCloudIdentity>
		{
			return _collection.RemoveExternalIdentity<TCloudIdentity, TService>();
		}


		/// <inheritdoc cref="PlayerAccounts.ResetPassword"/>
		public Promise<PasswordResetOperation> ResetPassword()
		{
			return _collection.ResetPassword(this);
		}

		/// <inheritdoc cref="PlayerAccounts.ConfirmPassword"/>
		public async Promise<PasswordResetConfirmOperation> ConfirmPassword(string code, string newPassword)
		{
			return await _collection.ConfirmPassword(code, newPassword, this);
		}

		/// <inheritdoc cref="PlayerAccounts.SetLanguage"/>
		public Promise<PlayerAccount> SetLanguage(SystemLanguage language)
		{
			return _collection.SetLanguage(language, this);
		}


		/// <summary>
		/// Update the stat values of this <see cref="PlayerAccount"/>.
		/// This method is called automatically when using the
		/// <see cref="SetAlias"/>, <see cref="SetSubtext"/>, or <see cref="SetAvatar"/> methods.
		///
		/// Generally, it is not recommended that you use this method directly. If stats are
		/// out of date, consider calling the <see cref="PlayerAccounts.Refresh"/> method.
		/// </summary>
		/// <param name="stats">The latest stat collection for the account</param>
		public void Update(UserExtensions.StatCollection stats)
		{
			_stats = stats;
			_alias = stats.Get(AccountManagementConfiguration.Instance.DisplayNameStat);
			_avatar = stats.Get(AccountManagementConfiguration.Instance.AvatarStat);
			_subtext = stats.Get(AccountManagementConfiguration.Instance.SubtextStat);


			if (_collection?.Current != this && _collection?.Current?._gamerTag == _gamerTag)
			{
				_collection?.Current?.Update(stats);
			}
		}

		/// <summary>
		/// Update all of values of this <see cref="PlayerAccount"/> to mirror the values of the given account.
		/// Generally, it is not recommended that you use this method directly. If data is
		/// out of date, consider calling the <see cref="PlayerAccounts.Refresh"/> method.
		/// </summary>
		/// <param name="other">The account to mirror</param>
		public void Update(PlayerAccount other)
		{
			Update(other._user);
			Update(other._stats);
			Update(other.token);
		}

		/// <summary>
		/// Update all of the user related data of this  <see cref="PlayerAccount"/> based on the given user.
		/// Generally, it is not recommended that you use this method directly. If data is
		/// out of date, consider calling the <see cref="PlayerAccounts.Refresh"/> method.
		/// </summary>
		/// <param name="user">the latest user object</param>
		public void Update(User user)
		{
			_user = user;

			_email = _user?.email;
			_deviceIds = user?.deviceIds?.ToArray() ?? new string[] { };

			var thirdPartyStrings = user?.thirdPartyAppAssociations.ToArray();
			_thirdParties = new AuthThirdParty[thirdPartyStrings?.Length ?? 0];
			for (var i = 0; i < _thirdParties.Length; i++)
			{
				_thirdParties[i] = AuthThirdPartyMethods.GetAuthThirdParty(thirdPartyStrings[i]);
			}

			_externalIdentities = new ExternalIdentity[user?.external?.Count ?? 0];
			for (var i = 0; i < _externalIdentities.Length; i++)
			{
				_externalIdentities[i] = new ExternalIdentity
				{
					providerNamespace = user.external[i].providerNamespace,
					providerService = user.external[i].providerService,
					userId = user.external[i].userId,
				};
			}

			_language = SessionServiceHelper.GetSystemLanguageFromIso639CountryCode(user?.language);
			_scopes = user?.scopes?.ToArray() ?? new string[] { };
			_gamerTag = _user?.id ?? 0;

			try
			{
				if (_collection?.Current != this && _collection?.Current?._gamerTag == _gamerTag)
				{
					// TODO: does the stat system still need to call the setter if this is true?
					_collection?.Current?.Update(user);
				}
			}
			catch (NullReferenceException ex)
			{
				Debug.LogException(ex);
			}
		}

		/// <summary>
		/// Update the current account's token.
		/// Generally, it is not recommended that you use this method directly. If data is
		/// out of date, consider calling the <see cref="PlayerAccounts.Refresh"/> method.
		/// </summary>
		/// <param name="token"></param>
		public void Update(BeamableToken token)
		{
			this.token.Update(token);
			if (_collection?.Current != this && _collection?.Current?._gamerTag == _gamerTag)
			{
				_collection.Current?.Update(token);
			}
		}

		public void TryTriggerUpdate()
		{
			TriggerUpdate();
			if (_collection?.Current != this && _collection?.Current?._gamerTag == _gamerTag)
			{
				_collection?.Current?.TriggerUpdate();
			}
		}

		long IUserContext.UserId => _gamerTag;
	}

	[Serializable]
	public class BeamableToken
	{
		#region auto generated equality members
		protected bool Equals(BeamableToken other)
		{
			return _accessToken == other._accessToken && _refreshToken == other._refreshToken && _expiresIn == other._expiresIn && _type == other._type;
		}

		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj))
			{
				return false;
			}

			if (ReferenceEquals(this, obj))
			{
				return true;
			}

			if (obj.GetType() != this.GetType())
			{
				return false;
			}

			return Equals((BeamableToken)obj);
		}

		public override int GetHashCode()
		{
			unchecked
			{
				var hashCode = (_accessToken != null ? _accessToken.GetHashCode() : 0);
				hashCode = (hashCode * 397) ^ (_refreshToken != null ? _refreshToken.GetHashCode() : 0);
				hashCode = (hashCode * 397) ^ _expiresIn.GetHashCode();
				hashCode = (hashCode * 397) ^ (_type != null ? _type.GetHashCode() : 0);
				return hashCode;
			}
		}

		#endregion

		/// <summary>
		/// The access token is used for authenticating all requests.
		/// </summary>
		public string AccessToken => _accessToken;

		/// <summary>
		/// The refresh token is used to generate a new access token.
		/// </summary>
		public string RefreshToken => _refreshToken;

		/// <summary>
		/// The type of token, usually "token".
		/// </summary>
		public string Type => _type;

		/// <summary>
		/// The number of ms until the access token expires and new one will be required.
		/// </summary>
		public long ExpiresIn => _expiresIn;

		[SerializeField]
		private string _accessToken;

		[SerializeField]
		private string _refreshToken;

		[SerializeField]
		private long _expiresIn;

		[SerializeField]
		private string _type;

		/// <summary>
		/// Update the values of this token to mirror another token.
		/// </summary>
		/// <param name="token"></param>
		public void Update(BeamableToken token)
		{
			this._type = token._type;
			this._accessToken = token._accessToken;
			this._refreshToken = token._refreshToken;
			this._expiresIn = token._expiresIn;
		}

		public static implicit operator BeamableToken(TokenResponse data) =>
			new BeamableToken
			{
				_accessToken = data.access_token,
				_refreshToken = data.refresh_token,
				_expiresIn = data.expires_in,
				_type = data.token_type,
			};

		public static BeamableToken FromAccessToken(IAccessToken data) =>
			new BeamableToken
			{
				_accessToken = data.Token,
				_refreshToken = data.RefreshToken,
				_expiresIn = (long)(data.ExpiresAt - DateTime.UtcNow).TotalMilliseconds,
				_type = "token",
			};

		public static implicit operator TokenResponse(BeamableToken data) =>
			new TokenResponse
			{
				access_token = data._accessToken,
				refresh_token = data._refreshToken,
				expires_in = data._expiresIn,
				token_type = data._type,
			};
	}

	public delegate Promise<string> AsyncChallengeHandler(string challenge);


	public delegate string ChallengeHandler(string challenge);

	/// <summary>
	/// The <see cref="RegistrationResult"/> has information about what happened
	/// after attempting to add a credential to a <see cref="PlayerAccount"/>.
	///
	/// If any error occured, the <see cref="isSuccess"/> field will be false,
	/// and the <see cref="error"/> value will contain more detail.
	///
	/// Otherwise, the <see cref="account"/> field will be accessible.
	/// </summary>
	[Serializable]
	public class RegistrationResult
	{
		/// <summary>
		/// The type of error that occured, if <see cref="isSuccess"/> is false.
		/// </summary>
		public PlayerRegistrationError error;

		[SerializeField]
		private PlayerAccount _account;

		/// <summary>
		/// True if the registration was successful.
		/// If not, see the <see cref="error"/> field for more detail.
		/// </summary>
		public bool isSuccess => error == PlayerRegistrationError.NONE;

		/// <summary>
		/// The <see cref="PlayerAccount"/> after the registration
		/// </summary>
		/// <exception cref="PlayerRegistrationException">
		/// This cannot be accessed if <see cref="isSuccess"/> is false.
		/// If it is, an exception will be thrown.
		/// </exception>
		public PlayerAccount account
		{
			get
			{
				if (error == PlayerRegistrationError.NONE)
				{
					return _account;
				}

				throw new PlayerRegistrationException(error);
			}
			set => _account = value;
		}
	}


	/// <summary>
	/// The <see cref="PasswordResetOperation"/> contains the result of starting
	/// a password reset flow.
	/// </summary>
	[Serializable]
	public class PasswordResetOperation
	{
		private readonly PlayerAccounts _collection;

		/// <summary>
		/// If an error occured while attempting to reset a <see cref="PlayerAccount"/>'s password,
		/// then this value will be anything other than <see cref="PasswordResetError.NONE"/>.
		/// If the <see cref="account"/> property is accessed while this value is not none, then it
		/// will throw an exception. 
		/// </summary>
		public PasswordResetError error;

		/// <summary>
		/// True when the <see cref="error"/> is none.
		/// </summary>
		public bool isSuccess => error == PasswordResetError.NONE;

		[SerializeField]
		private PlayerAccount _account;

		/// <summary>
		/// Access the <see cref="PlayerAccount"/>.
		/// If there is an <see cref="error"/> value, then this accessor will throw an exception.
		/// </summary>
		/// <exception cref="PasswordResetException">Only thrown when the <see cref="error"/> value isn't none.</exception>
		public PlayerAccount account
		{
			get
			{
				if (error == PasswordResetError.NONE)
				{
					return _account;
				}

				throw new PasswordResetException(error);
			}
			set => _account = value;
		}


		public PasswordResetOperation(PlayerAccounts collection)
		{
			_collection = collection;
		}

		/// <summary>
		/// If the <see cref="isSuccess"/> field is true, then
		/// this method may be called with the new password and reset code.
		/// Calling <see cref="PlayerAccounts.ConfirmPassword"/> will have the same outcome.
		/// </summary>
		/// <param name="code">
		/// The code that was sent to the player's email address by
		/// invoking the <see cref="ResetPassword"/> method.
		/// </param>
		/// <param name="newPassword">A new password to assign to the email credential. </param>
		/// <returns></returns>
		public async Promise<PasswordResetConfirmOperation> Confirm(string code, string newPassword)
		{
			return await _collection.ConfirmPassword(code, newPassword, account);
		}
	}

	/// <summary>
	/// The <see cref="PasswordResetConfirmOperation"/> contain the results
	/// or a password confirmation.
	/// </summary>
	[Serializable]
	public class PasswordResetConfirmOperation
	{
		/// <summary>
		/// If an error occured while attempting to confirm a <see cref="PlayerAccount"/>'s password,
		/// then this value will be anything other than <see cref="PasswordResetConfirmError.NONE"/>.
		/// If the <see cref="account"/> property is accessed while this value is not none, then it
		/// will throw an exception. 
		/// </summary>
		public PasswordResetConfirmError error;

		/// <summary>
		/// True when the <see cref="error"/> is none.
		/// </summary>
		public bool isSuccess => error == PasswordResetConfirmError.NONE;

		[SerializeField]
		private PlayerAccount _account;

		/// <summary>
		/// Access the <see cref="PlayerAccount"/>.
		/// If there is an <see cref="error"/> value, then this accessor will throw an exception.
		/// </summary>
		/// <exception cref="PasswordResetConfirmException">Only thrown when the <see cref="error"/> value isn't none.</exception>
		public PlayerAccount account
		{
			get
			{
				if (error == PasswordResetConfirmError.NONE)
				{
					return _account;
				}

				throw new PasswordResetConfirmException(error);
			}
			set => _account = value;
		}
	}


	/// <summary>
	/// The <see cref="PlayerRecoveryOperation"/> has the results of an account recovery operation.
	/// Accounts can be recovered using the <see cref="PlayerAccounts.RecoverAccountWithEmail"/> method.
	///
	/// Use the <see cref="SwitchToAccount"/> method to switch to the recovered account.
	/// </summary> 
	[Serializable]
	public class PlayerRecoveryOperation
	{
		private Exception _innerException;

		/// <summary>
		/// If an error occured while attempting to recovery a <see cref="PlayerAccount"/>,
		/// then this value will be anything other than <see cref="PlayerRecoveryError.NONE"/>.
		/// If the <see cref="account"/> property is accessed while this value is not none, then it
		/// will throw an exception. 
		/// </summary>
		public PlayerRecoveryError error;

		/// <summary>
		/// True when the <see cref="error"/> is none.
		/// </summary>
		public bool isSuccess => error == PlayerRecoveryError.NONE;

		/// <summary>
		/// If the account already had a gamerTag in the current realm, then this value be true.
		/// When this value is false, it implies that the account exists in the CID scope, but not
		/// in the current PID scope. 
		/// </summary>
		public bool realmAlreadyHasGamerTag;

		[SerializeField]
		private PlayerAccount _account;

		/// <summary>
		/// Access the recovered <see cref="PlayerAccount"/>.
		/// If there is an <see cref="error"/> value, then this accessor will throw an exception.
		/// </summary>
		/// <exception cref="PlayerRecoveryException">Only thrown when the <see cref="error"/> value isn't none.</exception>
		public PlayerAccount account
		{
			get
			{
				if (error == PlayerRecoveryError.NONE)
				{
					return _account;
				}

				throw GetException();
			}
			set => _account = value;
		}

		/// <summary>
		/// Change the current <see cref="BeamContext"/>'s account to the recovered account.
		/// If the <see cref="error"/> value is anything other than none, this method will
		/// throw an exception.
		/// </summary>
		public async Promise SwitchToAccount()
		{
			await account.SwitchToAccount();
		}

		public PlayerRecoveryOperation()
		{

		}

		public PlayerRecoveryOperation(Exception ex, PlayerRecoveryError error)
		{
			this.error = error;
			_innerException = ex;
		}

		/// <summary>
		/// This function will create an <see cref="PlayerRecoveryException"/> instance that contains the error code
		/// and any inner exception.
		/// </summary>
		/// <returns></returns>
		public PlayerRecoveryException GetException()
		{
			return new PlayerRecoveryException(error, _innerException);
		}
	}


	/// <summary>
	/// An exception that can be thrown if there is an error during an account recovery.
	/// </summary>
	public class PlayerRecoveryException : Exception
	{

		public PlayerRecoveryError Error { get; }

		public PlayerRecoveryException(PlayerRecoveryError error, Exception innerException = null)
			: base($"The recovery failed. error=[{error}]", innerException)
		{
			Error = error;
		}

		public PlayerRecoveryException(PlayerRecoveryError error, string message, Exception innerException = null)
			: base($"The recovery failed. error=[{error}] message=[{message}]", innerException)
		{

		}
	}

	/// <summary>
	/// An exception that can be thrown if there is an error while adding a credential to an account.
	/// </summary>
	public class PlayerRegistrationException : Exception
	{

		public PlayerRegistrationError Error { get; }

		public PlayerRegistrationException(PlayerRegistrationError error)
			: base($"The registration failed. error=[{error}]")
		{
			Error = error;
		}
	}

	/// <summary>
	/// An exception that can be thrown if there is an error while starting a password reset flow.
	/// </summary>
	public class PasswordResetException : Exception
	{

		public PasswordResetError Error { get; }

		public PasswordResetException(PasswordResetError error)
			: base($"The password reset failed. error=[{error}]")
		{
			Error = error;
		}
	}

	/// <summary>
	/// An exception that can be thrown if there is an error while confirming a password reset flow.
	/// </summary>
	public class PasswordResetConfirmException : Exception
	{
		public PasswordResetConfirmError Error { get; }

		public PasswordResetConfirmException(PasswordResetConfirmError error)
			: base($"The password confirm failed. error=[{error}]")
		{
			Error = error;
		}
	}

	/// <summary>
	/// The <see cref="PlayerRecoveryError"/> lists out the possible errors
	/// that could occur when trying to recover a <see cref="PlayerAccount"/>
	/// </summary>
	public enum PlayerRecoveryError
	{
		/// <summary>
		/// Represents that no error occured
		/// </summary>
		NONE,

		/// <summary>
		/// Represents that the given credentials weren't valid, or didn't map to an existing <see cref="PlayerAccount"/>
		/// </summary>
		UNKNOWN_CREDENTIALS,

		/// <summary>
		/// Represents that the given recovery did not specify enough information to login 
		/// </summary>
		INSUFFICIENT_DATA,

		/// <summary>
		/// Represents that the given recovery did not work, but the error isn't classified. 
		/// </summary>
		UNKNOWN_ERROR
	}

	/// <summary>
	/// The <see cref="PlayerRecoveryError"/> lists out the possible errors that
	/// could occur when trying to add a credential to a <see cref="PlayerAccount"/>
	/// </summary>
	public enum PlayerRegistrationError
	{
		/// <summary>
		/// represents no error occured.
		/// </summary>
		NONE,

		/// <summary>
		/// represents that the <see cref="PlayerAccount"/> already has a value
		/// for the credential. For example, a single account cannot have more
		/// than 1 email address or 1 linked facebook account.
		/// </summary>
		ALREADY_HAS_CREDENTIAL,

		/// <summary>
		/// represents that the given credential is already in use by a different <see cref="PlayerAccount"/>
		/// </summary>
		CREDENTIAL_IS_ALREADY_TAKEN
	}

	/// <summary>
	/// The <see cref="PasswordResetError"/> lists the possible errors
	/// that could occur when starting a password reset flow.
	/// </summary>
	public enum PasswordResetError
	{
		/// <summary>
		/// represents that no error occured.
		/// </summary>
		NONE,

		/// <summary>
		/// represents that the credential was not present on the account.
		/// </summary>
		NO_EXISTING_CREDENTIAL
	}

	/// <summary>
	/// the <see cref="PasswordResetConfirmError"/> represents the possible
	/// errors that could occur while confirming a password reset.
	/// </summary>
	public enum PasswordResetConfirmError
	{
		/// <summary>
		/// represents that no error occured.
		/// </summary>
		NONE,
	}


	[Serializable]
	public class PlayerAccounts : AbsObservableReadonlyList<PlayerAccount>
	{
		private readonly BeamContext _ctx;
		private readonly IAuthService _authService;
		private readonly AccessTokenStorage _storage;
		private readonly IBeamableRequester _requester;
		private readonly IStatsApi _stats;
		private readonly Api.Autogenerated.Stats.IStatsApi _statsApi;
		internal readonly IDependencyProvider _provider;


		/// <summary>
		/// The currently signed in <see cref="PlayerAccount"/>.
		/// There is always a current account, but it may be anonymous.
		/// </summary>
		public PlayerAccount Current;

		public Promise OnReady;

		public PlayerAccounts(BeamContext ctx,
							  IAuthService authService,
							  AccessTokenStorage storage,
							  IBeamableRequester requester,
							  IStatsApi stats,
							  Api.Autogenerated.Stats.IStatsApi statsApi,
							  IDependencyProvider provider)
		{
			_ctx = ctx;
			_authService = authService;
			_storage = storage;
			_requester = requester;
			_stats = stats;
			_statsApi = statsApi;
			_provider = provider;
			OnReady = Refresh();
		}



		/// <summary>
		/// Change the current <see cref="BeamContext"/>'s current user to the given account.
		/// After this method finishes, the given <see cref="account"/> will be the <see cref="Current"/> account.
		/// </summary>
		/// <param name="account"></param>
		public async Promise SwitchToAccount(PlayerAccount account)
		{
			_storage.StoreDeviceRefreshToken(_ctx.Cid, _ctx.Pid,
											 new AccessToken(_storage, _ctx.Cid, _ctx.Pid, _ctx.AccessToken.Token,
															 _ctx.AccessToken.RefreshToken, 1));
			await _ctx.ChangeAuthorizedPlayer(account.token);
			await Refresh();
		}

		/// <summary>
		/// Create a new anonymous account.
		/// The new account will be returned, and will be accessible in the <see cref="PlayerAccounts"/> list
		/// To switch to this new account, use the <see cref="SwitchToAccount"/> method.
		/// </summary>
		/// <returns>The newly created <see cref="PlayerAccount"/></returns>
		public async Promise<PlayerAccount> CreateNewAccount()
		{
			var tokenResponse = await _authService.CreateUser();
			var accessToken = new AccessToken(_storage, _ctx.Cid, _ctx.Pid, tokenResponse.access_token,
											  tokenResponse.refresh_token, tokenResponse.expires_in);
			_storage.StoreDeviceRefreshToken(_ctx.Cid, _ctx.Pid, accessToken);
			var user = await _authService.GetUser(tokenResponse);
			await Refresh();
			return this.FirstOrDefault(x => x.GamerTag == user.id);
		}

		/// <summary>
		/// Set the given <see cref="PlayerAccount"/>'s subtext value.
		/// The subtext can be used to show a small amount of account detail.
		/// </summary>
		/// <param name="subtext">the new subtext value</param>
		/// <param name="account">the <see cref="PlayerAccount"/> to use. If null is given, the <see cref="Current"/> account is used.</param>
		/// <returns>The modified <see cref="PlayerAccount"/></returns>
		public Promise<PlayerAccount> SetSubtext(string subtext, PlayerAccount account = null) =>
			SetStatValue(AccountManagementConfiguration.Instance.SubtextStat.StatKey, subtext, account);

		/// <summary>
		/// Set the given <see cref="PlayerAccount"/>'s alias value.
		/// The alias is used to show a display name for the account.
		/// </summary>
		/// <param name="alias">the new alias value</param>
		/// <param name="account">the <see cref="PlayerAccount"/> to use. If null is given, the <see cref="Current"/> account is used.</param>
		/// <returns>The modified <see cref="PlayerAccount"/></returns>
		public Promise<PlayerAccount> SetAlias(string alias, PlayerAccount account = null) =>
			SetStatValue(AccountManagementConfiguration.Instance.DisplayNameStat.StatKey, alias, account);

		/// <summary>
		/// Set the given <see cref="PlayerAccount"/>'s avatar value.
		/// The avatar can be used to record which avatar entry to use.
		/// </summary>
		/// <param name="avatar">the new avatar value</param>
		/// <param name="account">the <see cref="PlayerAccount"/> to use. If null is given, the <see cref="Current"/> account is used.</param>
		/// <returns>The modified <see cref="PlayerAccount"/></returns>
		public Promise<PlayerAccount> SetAvatar(string avatar, PlayerAccount account = null) =>
			SetStatValue(AccountManagementConfiguration.Instance.AvatarStat.StatKey, avatar, account);

		private async Promise<PlayerAccount> SetStatValue(string key, string value, PlayerAccount account)
		{
			if (account == null)
			{
				account = Current;
			}

			var statsService = GetStatsServiceForAccount(account);
			await statsService.SetStats("public",
										new Dictionary<string, string>
										{
											[key] = value
										});
			await Refresh();
			_stats.ClearCaches();
			return account;
		}

		/// <summary>
		/// Find an existing account by email and password.
		///
		/// Depending on the state of the realm, this method may produce different behaviour.
		/// The returned <see cref="PlayerRecoveryOperation"/> will either contain the <see cref="PlayerAccount"/>
		/// for the given <see cref="email"/> and <see cref="password"/>, or it will have a <see cref="PlayerRecoveryError"/> value.
		///
		/// </summary>
		/// <param name="email">
		/// A valid email address that was previously added to <see cref="PlayerAccount"/>.
		/// Email credentials can be added with the <see cref="AddEmail"/> method, or the PlayerAccount's <see cref="PlayerAccount.AddEmail"/> method.
		/// </param>
		/// <param name="password">
		/// The password used to add the email address
		/// </param>
		/// <returns>A <see cref="PlayerRecoveryOperation"/> containing the <see cref="PlayerAccount"/> or a <see cref="PlayerRecoveryError"/> value.</returns>
		public Promise<PlayerRecoveryOperation> RecoverAccountWithEmail(string email, string password)
		{
			return RecoverAccount((auth, merge) => auth.Login(email, password, merge));
		}

		/// <summary>
		/// Find an existing account by the current deviceId
		///
		/// Depending on the state of the realm, this method may produce different behaviour.
		/// The returned <see cref="PlayerRecoveryOperation"/> will either contain the <see cref="PlayerAccount"/>
		/// for the current deviceId, or it will have a <see cref="PlayerRecoveryError"/> value.
		///
		/// </summary>
		/// <returns>A <see cref="PlayerRecoveryOperation"/> containing the <see cref="PlayerAccount"/> or a <see cref="PlayerRecoveryError"/> value.</returns>
		public Promise<PlayerRecoveryOperation> RecoverAccountWithDeviceId()
		{
			return RecoverAccount((auth, merge) => auth.LoginDeviceId(merge));
		}

		/// <summary>
		/// Find an existing account by a third party link.
		///
		/// Depending on the state of the realm, this method may produce different behaviour.
		/// The returned <see cref="PlayerRecoveryOperation"/> will either contain the <see cref="PlayerAccount"/>
		/// for the given <see cref="thirdParty"/> and <see cref="token"/>, or it will have a <see cref="PlayerRecoveryError"/> value.
		///
		/// </summary>
		/// <param name="thirdParty">
		/// A third party that was previously added to an account with the <see cref="AddThirdParty"/> method.
		/// </param>
		/// <param name="token">
		/// The auth token issued from the third party.
		/// </param>
		/// <returns>A <see cref="PlayerRecoveryOperation"/> containing the <see cref="PlayerAccount"/> or a <see cref="PlayerRecoveryError"/> value.</returns>
		public Promise<PlayerRecoveryOperation> RecoverAccountWithThirdParty(
			AuthThirdParty thirdParty,
			string token)
		{
			return RecoverAccount((auth, merge) => auth.LoginThirdParty(thirdParty, token, merge));
		}

		private async Promise<PlayerRecoveryOperation> RecoverAccount(
			Func<IAuthService, bool, Promise<TokenResponse>> loginFunction)
		{
			TokenResponse res;
			var op = new PlayerRecoveryOperation();
			try
			{
				try
				{
					res = await loginFunction(_authService, true);
				}
				catch (PlatformRequesterException ex) when (ex.Error?.error == "UnableToMergeError")
				{
					op.realmAlreadyHasGamerTag = true;
					res = await loginFunction(_authService, false);
				}
			}
			catch (PlayerRecoveryException ex)
			{
				return new PlayerRecoveryOperation(ex, PlayerRecoveryError.INSUFFICIENT_DATA);
			}
			catch (Exception ex)
			{
				return new PlayerRecoveryOperation(ex, PlayerRecoveryError.UNKNOWN_ERROR);
			}

			var user = await _authService.GetUser(res);
			var stats = await GetStatsForUser(user);

			op.account = new PlayerAccount(this, res, user, stats);
			return op;
		}

		/// <summary>
		/// Completes a password reset flow for the given <see cref="PlayerAccount"/>.
		/// </summary>
		/// <param name="code">
		/// The code that was sent to the player's email address by
		/// invoking the <see cref="ResetPassword"/> method.
		/// </param>
		/// <param name="newPassword">A new password to assign to the email credential. </param>
		/// <param name="account"></param>
		/// <returns></returns>
		public async Promise<PasswordResetConfirmOperation> ConfirmPassword(string code, string newPassword, PlayerAccount account = null)
		{
			if (account == null)
			{
				account = Current;
			}

			var res = new PasswordResetConfirmOperation { account = account };
			var service = GetAuthServiceForAccount(account);

			await service.ConfirmPasswordUpdate(code, newPassword);
			await Refresh();
			return res;
		}

		/// <summary>
		/// Initiates a password reset flow for the given <see cref="PlayerAccount"/>.
		/// If the given account does not have an email credential, the resulting
		/// <see cref="PasswordResetOperation"/>'s <see cref="PasswordResetOperation.isSuccess"/>
		/// field will be false.
		///
		/// After the password reset flow is started, a code will be sent to the account's
		/// email address. The code must be provided to the <see cref="ConfirmPassword"/> method,
		/// or the <see cref="PasswordResetOperation"/>'s <see cref="PasswordResetOperation.Confirm"/> method.
		/// </summary>
		/// <param name="account"></param>
		/// <returns></returns>
		public async Promise<PasswordResetOperation> ResetPassword(PlayerAccount account = null)
		{
			if (account == null)
			{
				account = Current;
			}

			var res = new PasswordResetOperation(this) { account = account };

			if (!account.HasEmail)
			{
				res.error = PasswordResetError.NO_EXISTING_CREDENTIAL;
				return res;
			}

			var service = GetAuthServiceForAccount(account);
			await service.IssuePasswordUpdate(account.Email);

			return res;
		}

		/// <summary>
		/// Removes all deviceID credentials from the given account.
		/// An account could have multiple if the player used multiple devices.
		/// 
		/// By default, the deviceID is the `SystemInfo.deviceUniqueIdentifier` value.
		/// However, it can be overriden by registering a custom <see cref="IDeviceIdResolver"/> instance.
		/// </summary>
		/// <param name="account"></param>
		public async Promise<PlayerAccount> RemoveAllDeviceIds(PlayerAccount account = null)
		{
			if (account == null)
			{
				account = Current;
			}

			var service = GetAuthServiceForAccount(account);
			var user = await service.RemoveAllDeviceIds();
			account.Update(user);
			account.TryTriggerUpdate();
			return account;
		}

		/// <summary>
		/// Removes the current deviceID credential from the given account.
		///
		/// By default, the deviceID is the `SystemInfo.deviceUniqueIdentifier` value.
		/// However, it can be overriden by registering a custom <see cref="IDeviceIdResolver"/> instance.
		/// </summary>
		/// <param name="account"></param>
		public async Promise<PlayerAccount> RemoveDeviceId(PlayerAccount account = null)
		{
			if (account == null)
			{
				account = Current;
			}

			var service = GetAuthServiceForAccount(account);
			var deviceId = await service.GetDeviceId();
			var user = await service.RemoveDeviceId();
			user.deviceIds.Remove(deviceId);
			account.Update(user);
			account.TryTriggerUpdate();

			return account;
		}

		/// <summary>
		/// Removes the third party credential from the given account.
		/// </summary>
		/// <param name="thirdParty">
		/// Which <see cref="AuthThirdParty"/> is being added to the <see cref="PlayerAccount"/>
		/// </param>
		/// <param name="token">
		/// The special token issued from the third party itself. This token's format and origin differ
		/// depending on which third party is being used.
		/// </param>
		/// <param name="account"></param>
		public async Promise<PlayerAccount> RemoveThirdParty(AuthThirdParty thirdParty, string token, PlayerAccount account = null)
		{
			if (account == null)
			{
				account = Current;
			}

			var service = GetAuthServiceForAccount(account);

			var user = await service.RemoveThirdPartyAssociation(thirdParty, token);
			account.Update(user);
			account.TryTriggerUpdate();

			return account;
		}

		/// <summary>
		/// Adds the deviceId credential to the given <see cref="PlayerAccount"/>,
		/// and returns a <see cref="RegistrationResult"/>. If the returned
		/// <see cref="RegistrationResult.isSuccess"/> is true, then the addition worked.
		/// Otherwise, check the <see cref="RegistrationResult.error"/> field.
		///
		/// If the deviceID has already been added to a different <see cref="PlayerAccount"/>,
		/// then the the resulting <see cref="RegistrationResult.error"/> field will be <see cref="PlayerRegistrationError.CREDENTIAL_IS_ALREADY_TAKEN"/>
		///
		/// By default, the deviceID is the `SystemInfo.deviceUniqueIdentifier` value.
		/// However, it can be overriden by registering a custom <see cref="IDeviceIdResolver"/> instance.
		/// </summary>
		/// <param name="account"></param>
		/// <returns>A <see cref="RegistrationResult"/> representing the result of the deviceId addition. </returns>
		public async Promise<RegistrationResult> AddDeviceId(PlayerAccount account = null)
		{
			if (account == null)
			{
				account = Current;
			}

			var res = new RegistrationResult { account = account };
			var service = GetAuthServiceForAccount(account);

			var isAvailable = await service.IsThisDeviceIdAvailable();
			if (!isAvailable)
			{
				res.error = PlayerRegistrationError.CREDENTIAL_IS_ALREADY_TAKEN;
				return res;
			}
			var user = await service.RegisterDeviceId();
			account.Update(user);
			await Refresh();
			return res;
		}

		/// <inheritdoc cref="RecoverAccountWithExternalIdentity{TCloudIdentity,TService}(string,Beamable.Player.AsyncChallengeHandler)"/>
		public Promise<PlayerRecoveryOperation> RecoverAccountWithExternalIdentity<TCloudIdentity, TService>(
			string token,
			ChallengeHandler challengeHandler)
			where TCloudIdentity : IThirdPartyCloudIdentity, new()
			where TService : IHaveServiceName, ISupportsFederatedLogin<TCloudIdentity> =>
			RecoverAccountWithExternalIdentity<TCloudIdentity, TService>(
				token, challenge => Promise<string>.Successful(challengeHandler(challenge)));


		/// <summary>
		/// Find an existing account by an external identity link
		///
		/// Depending on the state of the realm, this method may produce different behaviour.
		/// The returned <see cref="PlayerRecoveryOperation"/> will either contain the <see cref="PlayerAccount"/>
		/// for the given <see cref="TCloudIdentity"/>, <see cref="TService"/> and <see cref="token"/>, or it will have a <see cref="PlayerRecoveryError"/> value.
		///
		/// </summary>
		/// <param name="token">
		/// A unique token for the player from the external third party
		/// </param>
		/// <param name="challengeHandler">
		/// The server may request the client to meet a challenge. The <see cref="ChallengeHandler"/> will be given
		/// the challenge string from the server, and it must solve the challenge and return the solution. The solution
		/// will be given back to the server to validate identity. 
		/// </param>
		/// <typeparam name="TCloudIdentity">A <see cref="IThirdPartyCloudIdentity"/> type</typeparam>
		/// <typeparam name="TService">A <see cref="Microservice"/> that implements <see cref="TCloudIdentity"/></typeparam>
		/// <returns>A <see cref="PlayerRecoveryOperation"/> containing the <see cref="PlayerAccount"/> or a <see cref="PlayerRecoveryError"/> value.</returns>
		public Promise<PlayerRecoveryOperation> RecoverAccountWithExternalIdentity<TCloudIdentity, TService>(string token, AsyncChallengeHandler challengeHandler = null)
			where TCloudIdentity : IThirdPartyCloudIdentity, new()
			where TService : IHaveServiceName, ISupportsFederatedLogin<TCloudIdentity>
		{

			return RecoverAccount(async (auth, merge) =>
			{
				var client = _provider.GetService<TService>();
				var ident = new TCloudIdentity();

				async Promise<TokenResponse> HandleResponse(ExternalLoginResponse res)
				{
					if (res.tokenResponse.HasValue)
					{
						return res.tokenResponse.Value;
					}

					var challenge = res.challenge.Value;
					if (challengeHandler == null)
					{
						throw new PlayerRecoveryException(PlayerRecoveryError.INSUFFICIENT_DATA,
														  "A challenge was requested, but no challenge handler was provided.");
					}
					var solution = await challengeHandler?.Invoke(challenge.challenge);
					var nextRes = await auth.LoginExternalIdentity(token, client.ServiceName, ident.UniqueName, new ChallengeSolution
					{
						challenge_token = challenge.challenge,
						solution = solution
					}, mergeGamerTagToAccount: merge);
					return await HandleResponse(nextRes);
				}

				var loginRes = await auth.LoginExternalIdentity(token, client.ServiceName, ident.UniqueName, mergeGamerTagToAccount: merge);
				return await HandleResponse(loginRes);
			});
		}

		/// <inheritdoc cref="AddExternalIdentity{TCloudIdentity,TService}(string,Beamable.Player.AsyncChallengeHandler,Beamable.Player.PlayerAccount)"/>
		public Promise<RegistrationResult> AddExternalIdentity<TCloudIdentity, TService>(
			string token,
			ChallengeHandler challengeHandler,
			PlayerAccount account = null)
			where TCloudIdentity : IThirdPartyCloudIdentity, new()
			where TService : IHaveServiceName, ISupportsFederatedLogin<TCloudIdentity> =>
			AddExternalIdentity<TCloudIdentity, TService>(
				token, challenge => Promise<string>.Successful(challengeHandler(challenge)), account);


		/// <summary>
		/// Adds the external identity credential to the given <see cref="PlayerAccount"/>,
		/// and returns a <see cref="RegistrationResult"/>. If the returned
		/// <see cref="RegistrationResult.isSuccess"/> is true, then the addition worked.
		/// Otherwise, check the <see cref="RegistrationResult.error"/> field.
		///
		/// </summary>
		/// <param name="token">
		/// A unique player specific token from the external third party.
		/// </param>
		/// <param name="challengeHandler">
		/// The server may request the client to meet a challenge. The <see cref="ChallengeHandler"/> will be given
		/// the challenge string from the server, and it must solve the challenge and return the solution. The solution
		/// will be given back to the server to validate identity. 
		/// </param>
		/// <typeparam name="TCloudIdentity">A <see cref="IThirdPartyCloudIdentity"/> type</typeparam>
		/// <typeparam name="TService">A <see cref="Microservice"/> that implements <see cref="TCloudIdentity"/></typeparam>
		/// <param name="account"></param>
		/// <returns>A <see cref="RegistrationResult"/> representing the result of the deviceId addition. </returns>
		public async Promise<RegistrationResult> AddExternalIdentity<TCloudIdentity, TService>(string token, AsyncChallengeHandler challengeHandler = null, PlayerAccount account = null)
			where TCloudIdentity : IThirdPartyCloudIdentity, new()
			where TService : IHaveServiceName, ISupportsFederatedLogin<TCloudIdentity>
		{
			if (account == null)
			{
				account = Current;
			}

			var res = new RegistrationResult { account = account };
			var service = GetAuthServiceForAccount(account);

			var client = _provider.GetService<TService>();
			var ident = new TCloudIdentity();

			async Promise<User> HandleResponse(AttachExternalIdentityResponse response)
			{
				switch (response.result)
				{
					case "challenge":
						if (challengeHandler == null)
						{
							throw new InvalidOperationException("A challenge was requested, but no challenge handler was provided.");
						}
						var solution = await challengeHandler.Invoke(response.challenge_token);
						var solutionRes = await service.AttachIdentity(token, client.ServiceName, ident.UniqueName, new ChallengeSolution
						{
							challenge_token = response.challenge_token,
							solution = solution
						});
						return await HandleResponse(solutionRes);
					case "ok":
						var user = await service.GetUser();
						return user;
					default:
						return null;
				}
			}

			try
			{
				var authorizeRes = await service.AttachIdentity(token, client.ServiceName, ident.UniqueName);
				var user = await HandleResponse(authorizeRes);
				if (user == null)
				{
					res.error = PlayerRegistrationError.CREDENTIAL_IS_ALREADY_TAKEN;
					return res;
				}

				account.Update(user);
				account.TryTriggerUpdate();
			}
			catch (PlatformRequesterException)
			{
				res.error = PlayerRegistrationError.CREDENTIAL_IS_ALREADY_TAKEN;
				return res;
			}

			await Refresh();
			return res;
		}

		/// <summary>
		/// Removes the external identity from the given account.
		/// </summary>
		/// <typeparam name="TCloudIdentity">A <see cref="IThirdPartyCloudIdentity"/> type</typeparam>
		/// <typeparam name="TService">A <see cref="Microservice"/> that implements <see cref="TCloudIdentity"/></typeparam>
		/// <param name="account"></param>
		public async Promise<PlayerAccount> RemoveExternalIdentity<TCloudIdentity, TService>(PlayerAccount account = null)
			where TCloudIdentity : IThirdPartyCloudIdentity, new()
			where TService : IHaveServiceName, ISupportsFederatedLogin<TCloudIdentity>
		{
			if (account == null)
			{
				account = Current;
			}

			var service = GetAuthServiceForAccount(account);

			var client = _provider.GetService<TService>();
			var ident = new TCloudIdentity();

			if (!account.TryGetExternalIdentity<TCloudIdentity, TService>(out var identity))
			{
				return account;
			}

			await service.DetachIdentity(client.ServiceName, identity.userId, ident.UniqueName);
			var user = await service.GetUser();
			account.Update(user);
			account.TryTriggerUpdate();

			return account;
		}

		/// <summary>
		/// Adds the third party credential to the given <see cref="PlayerAccount"/>,
		/// and returns a <see cref="RegistrationResult"/>. If the returned
		/// <see cref="RegistrationResult.isSuccess"/> is true, then the addition worked.
		/// Otherwise, check the <see cref="RegistrationResult.error"/> field.
		///
		/// If the third party token has already been added to a different <see cref="PlayerAccount"/>,
		/// then the the resulting <see cref="RegistrationResult.error"/> field will be <see cref="PlayerRegistrationError.CREDENTIAL_IS_ALREADY_TAKEN"/>
		///
		/// To get the token, follow the available <a href="https://docs.beamable.com/docs/identity">documentation </a>
		/// </summary>
		/// <param name="thirdParty">
		/// Which <see cref="AuthThirdParty"/> is being added to the <see cref="PlayerAccount"/>
		/// </param>
		/// <param name="token">
		/// The special token issued from the third party itself. This token's format and origin differ
		/// depending on which third party is being used.
		/// </param>
		/// <param name="account"></param>
		/// <returns>A <see cref="RegistrationResult"/> representing the result of the deviceId addition. </returns>
		public async Promise<RegistrationResult> AddThirdParty(AuthThirdParty thirdParty, string token, PlayerAccount account = null)
		{
			if (account == null)
			{
				account = Current;
			}

			var res = new RegistrationResult { account = account };
			var service = GetAuthServiceForAccount(account);

			if (account.HasThirdParty(thirdParty))
			{
				res.error = PlayerRegistrationError.ALREADY_HAS_CREDENTIAL;
				return res;
			}

			try
			{
				var user = await service.RegisterThirdPartyCredentials(thirdParty, token);
				account.Update(user);
				account.TryTriggerUpdate();
			}
			catch (PlatformRequesterException)
			{
				res.error = PlayerRegistrationError.CREDENTIAL_IS_ALREADY_TAKEN;
				return res;
			}
			await Refresh();
			return res;
		}

		/// <summary>
		/// Checks if the given third party token is available for usage.
		/// </summary>
		/// <returns>True when the token is available, false if taken.</returns>
		public async Promise<bool> IsThirdPartyAvailable(AuthThirdParty thirdParty, string token)
		{
			return await _authService.IsThirdPartyAvailable(thirdParty, token);
		}

		/// <summary>
		/// Adds an email credential to the given <see cref="PlayerAccount"/>,
		/// and returns a <see cref="RegistrationResult"/>. If the returned
		/// <see cref="RegistrationResult.isSuccess"/> is true, then the addition worked.
		/// Otherwise, check the <see cref="RegistrationResult.error"/> field.
		/// </summary>
		/// <param name="email">
		/// The email to add to the account.
		/// This email must be unique for the CID.
		/// If the email is already taken, the resulting <see cref="RegistrationResult.error"/> field will be <see cref="PlayerRegistrationError.CREDENTIAL_IS_ALREADY_TAKEN"/>
		/// </param>
		/// <param name="password">
		/// The password to combine with the email address.
		/// </param>
		/// <param name="account"></param>
		/// <returns>A <see cref="RegistrationResult"/> representing the result of the email addition. </returns>
		public async Promise<RegistrationResult> AddEmail(string email, string password, PlayerAccount account = null)
		{
			if (account == null)
			{
				account = Current;
			}

			var res = new RegistrationResult { account = account };
			if (account.HasEmail)
			{
				res.error = PlayerRegistrationError.ALREADY_HAS_CREDENTIAL;
				return res;
			}

			var service = GetAuthServiceForAccount(account);
			try
			{
				var user = await service.RegisterDBCredentials(email, password);
				account.Update(user);
				account.TryTriggerUpdate();
			}
			catch (RequesterException ex) when (ex.Status == 400 && ex.RequestError.error == "EmailAlreadyRegisteredError")
			{
				res.error = PlayerRegistrationError.CREDENTIAL_IS_ALREADY_TAKEN;
				return res;
			}

			await Refresh();

			return res;
		}

		/// <summary>
		/// Checks if the provided email is already attached to a player account.
		/// </summary>
		/// <returns>True when email is free to be used, false when it's already taken.</returns>
		public async Promise<bool> IsEmailAvailable(string email)
		{
			return await _authService.IsEmailAvailable(email);
		}

		/// <summary>
		/// Removes the given <see cref="PlayerAccount"/> from the device's memory.
		/// After the account is removed, the access token will be lost. The player
		/// will not be able to switch to this account until they initiate an account
		/// recovery option.
		///
		/// If the given account is the currently active account, then nothing will happen.
		/// It is impossible to remove the current account.
		///
		/// </summary>
		/// <param name="account"></param>
		public async Promise RemoveAccount(PlayerAccount account)
		{
			if (account == null || account.GamerTag == Current.GamerTag) return;

			_storage.RemoveDeviceRefreshToken(_ctx.Cid, _ctx.Pid, account.token);
			await Refresh();
		}

		/// <summary>
		/// Removes all accounts from the device's memory.
		/// After each account is removed, the access token will be lost. The player
		/// will not be able to switch to this account until they initiate an account
		/// recovery option.
		///
		/// The currently active account will still be available on the device.
		/// </summary>
		public async Promise RemoveAllAccounts()
		{
			// this won't clear the current user, just the other stored ones.
			_storage.ClearDeviceRefreshTokens(_ctx.Cid, _ctx.Pid);
			await Refresh();
		}

		/// <summary>
		/// Set the given <see cref="PlayerAccount"/>'s language preference.
		/// </summary>
		/// <param name="language">A <see cref="SystemLanguage"/></param>
		/// <param name="account"></param>
		/// <returns></returns>
		public async Promise<PlayerAccount> SetLanguage(SystemLanguage language, PlayerAccount account = null)
		{
			if (account == null)
			{
				account = Current;
			}

			var service = GetAuthServiceForAccount(account);
			var user = await service.SetLanguage(language);
			account.Update(user);
			account.TryTriggerUpdate();
			return account;
		}

		private IDependencyProvider GetScopeForAccount(PlayerAccount account)
		{
			if (account.GamerTag == Current.GamerTag) return _provider;
			var requester = _requester.WithAccessToken(account.token);
			return _provider.Fork(builder =>
			{
				builder
					.AddScoped(requester)
					.Remove<StatsService>()
					.AddScoped<StatsService>(provider =>
												 new StatsService(
													 account,
													 requester,
													 provider,
													 UnityUserDataCache<Dictionary<string, string>>
														 .CreateInstance,
													 provider.GetService<OfflineCache>()));
				;
			});
		}

		private IAuthService GetAuthServiceForAccount(PlayerAccount account)
		{
			var subScope = GetScopeForAccount(account);
			return subScope.GetService<IAuthService>();
		}

		private IStatsApi GetStatsServiceForAccount(PlayerAccount account)
		{
			var subScope = GetScopeForAccount(account);
			return subScope.GetService<IStatsApi>();
		}

		private Promise<UserExtensions.StatCollection> GetStatsForUser(User user)
		{
			return user.GetStats(
				AccountManagementConfiguration.Instance.DisplayNameStat,
				AccountManagementConfiguration.Instance.SubtextStat,
				AccountManagementConfiguration.Instance.AvatarStat);
		}

		protected override async Promise PerformRefresh()
		{
			await _ctx.OnReady;

			var next = new List<PlayerAccount>(Count);
			var gamerTagToAccount = new Dictionary<long, PlayerAccount>();
			foreach (var account in this)
			{
				gamerTagToAccount[account.GamerTag] = account;
			}

			var seen = new HashSet<long>();

			var deviceTokens = _storage.RetrieveDeviceRefreshTokens(_ctx.Cid, _ctx.Pid);
			var currToken = _storage.LoadTokenForRealmImmediate(_ctx.Cid, _ctx.Pid);
			var tokens = new TokenResponse[deviceTokens.Length + 1];
			for (var i = 0; i < deviceTokens.Length; i++)
			{
				tokens[i] = deviceTokens[i];
			}
			tokens[deviceTokens.Length] = new TokenResponse { access_token = currToken.Token, refresh_token = currToken.RefreshToken, };

			var userPromises = new Promise<User>[tokens.Length];
			var statPromises = new Promise<UserExtensions.StatCollection>[tokens.Length];
			for (var i = 0; i < userPromises.Length; i++)
			{
				userPromises[i] = _authService.GetUser(tokens[i]);
				statPromises[i] = userPromises[i].FlatMap(GetStatsForUser);
			}
			var users = await Promise.Sequence(userPromises);
			var stats = await Promise.Sequence(statPromises);

			for (var i = 0; i < userPromises.Length; i++)
			{
				var user = users[i];
				if (seen.Contains(user.id)) continue;
				seen.Add(user.id);

				var statValues = stats[i];
				var token = tokens[i];



				if (gamerTagToAccount.TryGetValue(user.id, out var existing))
				{
					existing.Update(statValues);
					existing.Update(user);
					existing.Update(token);
					existing.TryTriggerUpdate();
					next.Add(existing);
					if (user.id == _ctx.PlayerId)
					{
						if (Current == null) Current = existing;
						Current.Update(existing);
					}
				}
				else
				{
					var newAccount = new PlayerAccount(this, token, user, statValues);
					gamerTagToAccount.Add(user.id, newAccount);
					next.Add(newAccount);

					if (user.id == _ctx.PlayerId)
					{
						if (Current == null) Current = newAccount;
						Current.Update(newAccount);
					}
				}
			}

			SetData(next);
		}
	}
}
